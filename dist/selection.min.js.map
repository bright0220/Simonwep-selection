{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/utils.js","webpack:///./src/selection.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","eventListener","method","elements","events","fn","options","HTMLCollection","NodeList","Array","from","isArray","element","event","capture","slice","arguments","on","off","unitify","val","unit","css","el","attr","style","entries","intersects","a","b","bxc","left","width","byc","top","height","right","bottom","selectAll","selector","nodes","length","item","push","document","querySelectorAll","HTMLElement","eventPath","evt","path","composedPath","target","parentElement","removeElement","arr","index","indexOf","splice","simplifyEvent","tap","touches","x","clientX","y","clientY","abs","max","min","round","ceil","Math","doc","preventDefault","e","Selection","that","assign","class","tapMode","startThreshold","singleClick","disableTouch","selectables","scrollSpeedDivider","manualScrollSpeed","startareas","boundaries","selectionAreaContainer","_stored","_selectables","_selected","_changed","added","removed","_eventListener","beforestart","start","move","stop","_area","createElement","_clippingElement","_scrollAvailable","_scrollSpeed","_init","appendChild","classList","add","willChange","position","overflow","transform","pointerEvents","zIndex","enable","_bindStartEvents","type","_onTapStart","passive","targetBoundingClientRect","getBoundingClientRect","startAreas","_boundaries","_targetContainer","find","evtpath","includes","_emit","_ax1","_ay1","_ax2","_ay2","_singleClick","clearSelection","_delayedTapMove","_onTapStop","_onSingleTap","spl","resolveSelectables","v","stored","shiftKey","reference","preceding","following","compareDocumentPosition","rangeItems","filter","select","removeFromSelection","thresholdType","_onTapMove","tb","_targetBoundary","scrollHeight","scrollWidth","_manualScroll","contains","marginTop","marginLeft","scon","ss","_redrawArea","_updatedTouchingElements","requestAnimationFrame","scroll","scrollTop","scrollLeft","deltaY","deltaX","clientHeight","clientWidth","brect","x3","y3","x4","y4","noevent","remove","areaRect","touched","node","ok","listener","inst","area","selected","concat","changed","oe","cb","callBacks","keepSelection","store","getSelection","cancel","keepEvent","option","undefined","disable","destroy","query","utils","version"],"mappings":"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","file":"selection.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Selection\"] = factory();\n\telse\n\t\troot[\"Selection\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","function eventListener(method, elements, events, fn, options = {}) {\r\n\r\n    // Normalize array\r\n    if (elements instanceof HTMLCollection || elements instanceof NodeList) {\r\n        elements = Array.from(elements);\r\n    } else if (!Array.isArray(elements)) {\r\n        elements = [elements];\r\n    }\r\n\r\n    if (!Array.isArray(events)) events = [events];\r\n\r\n    for (const element of elements) {\r\n        for (const event of events) {\r\n            element[method](event, fn, {capture: false, ...options});\r\n        }\r\n    }\r\n\r\n    return Array.prototype.slice.call(arguments, 1);\r\n}\r\n\r\n/**\r\n * Add event(s) to element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const on = eventListener.bind(null, 'addEventListener');\r\n\r\n/**\r\n * Remove event(s) from element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const off = eventListener.bind(null, 'removeEventListener');\r\n\r\nconst unitify = (val, unit = 'px') => typeof val === 'number' ? val + unit : val;\r\n\r\n/**\r\n * Add css to a DOM-Element or returns the current\r\n * value of a property.\r\n *\r\n * @param el The Element.\r\n * @param attr The attribute or a object which holds css key-properties.\r\n * @param val The value for a single attribute.\r\n * @returns {*}\r\n */\r\nexport function css(el, attr, val) {\r\n    const style = el && el.style;\r\n    if (style) {\r\n        if (typeof attr === 'object') {\r\n\r\n            for (const [key, value] of Object.entries(attr)) {\r\n                style[key] = unitify(value);\r\n            }\r\n\r\n        } else if (val && typeof attr === 'string') {\r\n            style[attr] = unitify(val);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check if two DOM-Elements intersects each other.\r\n * @param a BoundingClientRect of the first element.\r\n * @param b BoundingClientRect of the second element.\r\n * @param mode Options are center, cover or touch.\r\n * @returns {boolean} If both elements intersects each other.\r\n */\r\nexport function intersects(a, b, mode) {\r\n    switch (mode || 'touch') {\r\n        case 'center': {\r\n            const bxc = b.left + b.width / 2;\r\n            const byc = b.top + b.height / 2;\r\n\r\n            return bxc >= a.left\r\n                && bxc <= a.right\r\n                && byc >= a.top\r\n                && byc <= a.bottom;\r\n        }\r\n        case 'cover': {\r\n            return b.left >= a.left\r\n                && b.top >= a.top\r\n                && b.right <= a.right\r\n                && b.bottom <= a.bottom;\r\n        }\r\n        case 'touch': {\r\n            return a.right >= b.left\r\n                && a.left <= b.right\r\n                && a.bottom >= b.top\r\n                && a.top <= b.bottom;\r\n        }\r\n        default: {\r\n            throw `Unkown intersection mode: ${mode}`;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Takes a selector (or array of selectors) and returns the matched nodes.\r\n * @param selector The selector or an Array of selectors.\r\n * @returns {Array} Array of DOM-Nodes.\r\n */\r\nexport function selectAll(selector) {\r\n    if (!Array.isArray(selector)) {\r\n        selector = [selector];\r\n    }\r\n\r\n    const nodes = [];\r\n    for (let i = 0, l = selector.length; i < l; i++) {\r\n        const item = selector[i];\r\n\r\n        if (typeof item === 'string') {\r\n            nodes.push(...document.querySelectorAll(item));\r\n        } else if (item instanceof HTMLElement) {\r\n            nodes.push(item);\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\n/**\r\n * Polyfill for safari & firefox for the eventPath event property.\r\n * @param evt The event object.\r\n * @return [String] event path.\r\n */\r\nexport function eventPath(evt) {\r\n    let path = evt.path || (evt.composedPath && evt.composedPath());\r\n\r\n    if (path) {\r\n        return path;\r\n    }\r\n\r\n    let el = evt.target;\r\n    for (path = [el]; (el = el.parentElement);) {\r\n        path.push(el);\r\n    }\r\n\r\n    path.push(document, window);\r\n    return path;\r\n}\r\n\r\n/**\r\n * Removes an element from an Array.\r\n */\r\nexport function removeElement(arr, el) {\r\n    const index = arr.indexOf(el);\r\n\r\n    if (~index) {\r\n        arr.splice(index, 1);\r\n    }\r\n}\r\n\r\nexport function simplifyEvent(evt) {\r\n    const tap = (evt.touches && evt.touches[0] || evt);\r\n    return {\r\n        tap,\r\n        x: tap.clientX,\r\n        y: tap.clientY,\r\n        target: tap.target\r\n    };\r\n}\r\n","import {css, eventPath, intersects, off, on, removeElement, selectAll, simplifyEvent} from './utils';\r\nimport {version}                                                                      from '../package';\r\n\r\n// Some var shorting for better compression and readability\r\nconst {abs, max, min, round, ceil} = Math;\r\nconst doc = document;\r\nconst preventDefault = e => e.preventDefault();\r\n\r\nfunction Selection(options = {}) {\r\n\r\n    const that = {\r\n\r\n        options: Object.assign({\r\n            class: 'selection-area',\r\n            mode: 'touch',\r\n            tapMode: 'native',\r\n            startThreshold: 10,\r\n            singleClick: true,\r\n            disableTouch: false,\r\n\r\n            selectables: [],\r\n            scrollSpeedDivider: 10,\r\n            manualScrollSpeed: 750,\r\n\r\n            startareas: ['html'],\r\n            boundaries: ['html'],\r\n            selectionAreaContainer: 'body'\r\n        }, options),\r\n\r\n        // Store for keepSelection\r\n        _stored: [],\r\n        _selectables: [],\r\n        _selected: [], // Currently touched elements\r\n        _changed: {\r\n            added: [],  // Added elements since last selection\r\n            removed: [] // Removed elements since last selection\r\n        },\r\n\r\n        // Evenlistener name: [callbacks]\r\n        _eventListener: {\r\n            beforestart: [],\r\n            start: [],\r\n            move: [],\r\n            stop: []\r\n        },\r\n\r\n        // Create area element\r\n        _area: doc.createElement('div'),\r\n        _clippingElement: doc.createElement('div'),\r\n\r\n        // Is getting set on movement. Varied.\r\n        _scrollAvailable: true,\r\n        _scrollSpeed: {x: null, y: null},\r\n\r\n        _init() {\r\n            that._clippingElement.appendChild(that._area);\r\n\r\n            // Add class to the area element\r\n            that._area.classList.add(that.options.class);\r\n\r\n            // Apply basic styles to the area element\r\n            css(that._area, {\r\n                willChange: 'top, left, bottom, right, width, height',\r\n                top: 0,\r\n                left: 0,\r\n                position: 'fixed'\r\n            });\r\n\r\n            css(that._clippingElement, {\r\n                overflow: 'hidden',\r\n                position: 'fixed',\r\n                transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\r\n                pointerEvents: 'none',\r\n                zIndex: '1'\r\n            });\r\n\r\n            that.enable();\r\n        },\r\n\r\n        _bindStartEvents(type) {\r\n            const fn = type === 'on' ? on : off;\r\n            fn(doc, 'mousedown', that._onTapStart);\r\n\r\n            if (!that.options.disableTouch) {\r\n                fn(doc, 'touchstart', that._onTapStart, {\r\n                    passive: false\r\n                });\r\n            }\r\n        },\r\n\r\n        _onTapStart(evt) {\r\n            const {x, y, target} = simplifyEvent(evt);\r\n            const targetBoundingClientRect = target.getBoundingClientRect();\r\n\r\n            // Find start-areas and boundaries\r\n            const startAreas = selectAll(that.options.startareas);\r\n            that._boundaries = selectAll(that.options.boundaries);\r\n\r\n            // Check in which container the user currently acts\r\n            that._targetContainer = that._boundaries.find(el =>\r\n                intersects(el.getBoundingClientRect(), targetBoundingClientRect)\r\n            );\r\n\r\n            // Check if area starts in one of the start areas / boundaries\r\n            const evtpath = eventPath(evt);\r\n            if (!that._targetContainer ||\r\n                !startAreas.find(el => evtpath.includes(el)) ||\r\n                !that._boundaries.find(el => evtpath.includes(el))) {\r\n                return;\r\n            }\r\n\r\n            if (that._emit('beforestart', evt) === false) {\r\n                return;\r\n            }\r\n\r\n            // Area start point\r\n            that._ax1 = x;\r\n            that._ay1 = y;\r\n\r\n            // Area end point\r\n            that._ax2 = 0;\r\n            that._ay2 = 0;\r\n\r\n            // To detect single-click\r\n            that._singleClick = true;\r\n            that._selected = [];\r\n            that.clearSelection(false);\r\n\r\n            // Prevent default select event\r\n            on(doc, 'selectstart', preventDefault);\r\n\r\n            // Add listener\r\n            on(doc, ['touchmove', 'mousemove'], that._delayedTapMove, {passive: false});\r\n            on(doc, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\r\n\r\n            // Firefox will scroll down the page which would break the selection.\r\n            evt.preventDefault();\r\n        },\r\n\r\n        _onSingleTap(evt) {\r\n            const {tapMode} = that.options;\r\n            const spl = simplifyEvent(evt);\r\n            let target = null;\r\n\r\n            if (tapMode === 'native') {\r\n                target = spl.target;\r\n            } else if (tapMode === 'touch') {\r\n                that.resolveSelectables();\r\n\r\n                const {x, y} = spl;\r\n                target = that._selectables.find(v => {\r\n                    const {right, left, top, bottom} = v.getBoundingClientRect();\r\n                    return x < right && x > left && y < bottom && y > top;\r\n                });\r\n            } else {\r\n                throw `Unknown tapMode option: ${tapMode}`;\r\n            }\r\n\r\n            if (!target) {\r\n                return false;\r\n            }\r\n\r\n            /**\r\n             * Resolve selectables again.\r\n             * If the user starded in a scrollable area they will be reduced\r\n             * to the current area. Prevent the exclusion of these if a range-selection\r\n             * gets performed.\r\n             */\r\n            that.resolveSelectables();\r\n\r\n            // Traverse dom upwards to check if target is selectable\r\n            while (!that._selectables.includes(target)) {\r\n                if (!target.parentElement) {\r\n                    return;\r\n                }\r\n\r\n                target = target.parentElement;\r\n            }\r\n\r\n            that._emit('start', evt);\r\n            const stored = that._stored;\r\n            if (evt.shiftKey && stored.length) {\r\n                const reference = stored[stored.length - 1];\r\n\r\n                // Resolve correct range\r\n                const [preceding, following] = reference.compareDocumentPosition(target) & 4 ? [target, reference] : [reference, target];\r\n\r\n                const rangeItems = [...that._selectables.filter(el =>\r\n                    (el.compareDocumentPosition(preceding) & 4) &&\r\n                    (el.compareDocumentPosition(following) & 2)\r\n                ), target];\r\n\r\n                that.select(rangeItems);\r\n                that._emit('move', evt);\r\n                that._emit('stop', evt);\r\n            } else {\r\n\r\n                if (that._stored.includes(target)) {\r\n                    that.removeFromSelection(target);\r\n                } else {\r\n                    that.select(target);\r\n                }\r\n\r\n                that._emit('move', evt);\r\n                that._emit('stop', evt);\r\n            }\r\n        },\r\n\r\n        _delayedTapMove(evt) {\r\n            const {x, y} = simplifyEvent(evt);\r\n            const {startThreshold} = that.options;\r\n            const {_ax1, _ay1} = that; // Coordinates of first \"tap\"\r\n\r\n            // Check pixel threshold\r\n            const thresholdType = typeof startThreshold;\r\n            if ((thresholdType === 'number' && abs((x + y) - (_ax1 + _ay1)) >= startThreshold) ||\r\n                (thresholdType === 'object' && abs(x - _ax1) >= startThreshold.x || abs(y - _ay1) >= startThreshold.y)) {\r\n                off(doc, ['mousemove', 'touchmove'], that._delayedTapMove, {passive: false});\r\n                on(doc, ['mousemove', 'touchmove'], that._onTapMove, {passive: false});\r\n\r\n                // Make area element visible\r\n                css(that._area, 'display', 'block');\r\n\r\n                // Apppend selection-area to the dom\r\n                selectAll(that.options.selectionAreaContainer)[0].appendChild(that._clippingElement);\r\n\r\n                // Now after the threshold is reached resolve all selectables\r\n                that.resolveSelectables();\r\n\r\n                // An action is recognized as single-select until\r\n                // the user performed a mutli-selection\r\n                that._singleClick = false;\r\n\r\n                // Just saving the boundaries of this container for later\r\n                const tb = that._targetBoundary = that._targetContainer.getBoundingClientRect();\r\n\r\n                // Find container and check if it's scrollable\r\n                if (round(that._targetContainer.scrollHeight) !== round(tb.height) ||\r\n                    round(that._targetContainer.scrollWidth) !== round(tb.width)) {\r\n\r\n                    // Indenticates if the user is currently in a scrollable area\r\n                    that._scrollAvailable = true;\r\n\r\n                    // Detect mouse scrolling\r\n                    on(window, 'wheel', that._manualScroll, {passive: false});\r\n\r\n                    /**\r\n                     * The selection-area will also cover other element which are\r\n                     * out of the current scrollable parent. So find all elements\r\n                     * which are in the current scrollable element. Later these are\r\n                     * the only selectables instead of all.\r\n                     */\r\n                    that._selectables = that._selectables.filter(s => that._targetContainer.contains(s));\r\n\r\n                    /**\r\n                     * To clip the area, the selection area has a parent\r\n                     * which has exact the same dimensions as the scrollable elemeent.\r\n                     * Now if the area exeeds these boundaries it will be cropped.\r\n                     */\r\n                    css(that._clippingElement, {\r\n                        top: tb.top,\r\n                        left: tb.left,\r\n                        width: tb.width,\r\n                        height: tb.height\r\n                    });\r\n\r\n                    /**\r\n                     * The area element is relative to the clipping element,\r\n                     * but when this is moved or transformed we need to correct\r\n                     * the positions via a negative margin.\r\n                     */\r\n                    css(that._area, {\r\n                        marginTop: -tb.top,\r\n                        marginLeft: -tb.left\r\n                    });\r\n                } else {\r\n                    that._scrollAvailable = false;\r\n\r\n                    /**\r\n                     * Reset margin and clipping element dimensions.\r\n                     */\r\n                    css(that._clippingElement, {\r\n                        top: 0,\r\n                        left: 0,\r\n                        width: '100%',\r\n                        height: '100%'\r\n                    });\r\n\r\n                    css(that._area, {\r\n                        marginTop: 0,\r\n                        marginLeft: 0\r\n                    });\r\n                }\r\n\r\n                // Trigger recalc and fire event\r\n                that._onTapMove(evt);\r\n                that._emit('start', evt);\r\n            }\r\n\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        },\r\n\r\n        _onTapMove(evt) {\r\n            const {x, y} = simplifyEvent(evt);\r\n            const {scrollSpeedDivider} = that.options;\r\n            const scon = that._targetContainer;\r\n            let ss = that._scrollSpeed;\r\n            that._ax2 = x;\r\n            that._ay2 = y;\r\n\r\n            if (that._scrollAvailable && (ss.y !== null || ss.x !== null)) {\r\n\r\n                // Continous scrolling\r\n                requestAnimationFrame(function scroll() {\r\n\r\n                    // Make sure that ss is not outdated\r\n                    ss = that._scrollSpeed;\r\n\r\n                    // Scrolling is not anymore required\r\n                    if (ss.y === null && ss.x === null) {\r\n                        return;\r\n                    }\r\n\r\n                    /**\r\n                     * If the value exeeds the scrollable area it will\r\n                     * be set to the max / min value. So change only\r\n                     */\r\n                    const {scrollTop, scrollLeft} = scon;\r\n\r\n                    // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\r\n                    if (ss.y !== null) {\r\n                        scon.scrollTop += ceil(ss.y / scrollSpeedDivider);\r\n                        that._ay1 -= scon.scrollTop - scrollTop;\r\n                    }\r\n\r\n                    if (ss.x !== null) {\r\n                        scon.scrollLeft += ceil(ss.x / scrollSpeedDivider);\r\n                        that._ax1 -= scon.scrollLeft - scrollLeft;\r\n                    }\r\n\r\n                    /**\r\n                     * We changed the start coordinates ->  redraw the selectiona area\r\n                     * We changed the dimensions of the area element -> re-calc selected elements\r\n                     * The selected elements array has been changed -> fire event\r\n                     */\r\n                    that._redrawArea();\r\n                    that._updatedTouchingElements();\r\n                    that._emit('move', evt);\r\n\r\n                    // Keep scrolling even if the user stops to move his pointer\r\n                    requestAnimationFrame(scroll);\r\n                });\r\n            } else {\r\n\r\n                /**\r\n                 * Perform redraw only if scrolling is not active.\r\n                 * If scrolling is active this area is getting re-dragwed by the\r\n                 * anonymized scroll function.\r\n                 */\r\n                that._redrawArea();\r\n                that._updatedTouchingElements();\r\n                that._emit('move', evt);\r\n            }\r\n\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        },\r\n\r\n        _manualScroll(evt) {\r\n            const {manualScrollSpeed} = that.options;\r\n\r\n            // Consistent scrolling speed on all browsers\r\n            const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\r\n            const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\r\n            that._scrollSpeed.y += deltaY * manualScrollSpeed;\r\n            that._scrollSpeed.x += deltaX * manualScrollSpeed;\r\n            that._onTapMove(evt);\r\n\r\n            // Prevent defaul scrolling behaviour, eg. page scrolling\r\n            evt.preventDefault();\r\n        },\r\n\r\n        _redrawArea() {\r\n            const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = that._targetContainer;\r\n            const brect = that._targetBoundary;\r\n            const ss = that._scrollSpeed;\r\n            let x = that._ax2;\r\n            let y = that._ay2;\r\n\r\n            if (x < brect.left) {\r\n                ss.x = scrollLeft ? -abs(brect.left - x) : null;\r\n                x = brect.left;\r\n            } else if (x > brect.left + brect.width) {\r\n                ss.x = scrollWidth - scrollLeft - clientWidth ? abs(brect.left + brect.width - x) : null;\r\n                x = brect.left + brect.width;\r\n            } else {\r\n                ss.x = null;\r\n            }\r\n\r\n            if (y < brect.top) {\r\n                ss.y = scrollTop ? -abs(brect.top - y) : null;\r\n                y = brect.top;\r\n            } else if (y > brect.top + brect.height) {\r\n                ss.y = scrollHeight - scrollTop - clientHeight ? abs(brect.top + brect.height - y) : null;\r\n                y = brect.top + brect.height;\r\n            } else {\r\n                ss.y = null;\r\n            }\r\n\r\n            const x3 = min(that._ax1, x);\r\n            const y3 = min(that._ay1, y);\r\n            const x4 = max(that._ax1, x);\r\n            const y4 = max(that._ay1, y);\r\n\r\n            Object.assign(that._area.style, {\r\n                top: `${y3}px`,\r\n                left: `${x3}px`,\r\n                width: `${x4 - x3}px`,\r\n                height: `${y4 - y3}px`\r\n            });\r\n        },\r\n\r\n        _onTapStop(evt, noevent) {\r\n\r\n            // Remove event handlers\r\n            off(doc, ['mousemove', 'touchmove'], that._delayedTapMove);\r\n            off(doc, ['touchmove', 'mousemove'], that._onTapMove);\r\n            off(doc, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\r\n\r\n            if (evt && that._singleClick && that.options.singleClick) {\r\n                that._onSingleTap(evt);\r\n            } else if (!that._singleClick && !noevent) {\r\n                that._updatedTouchingElements();\r\n                that._emit('stop', evt);\r\n            }\r\n\r\n            // Reset scroll speed\r\n            that._scrollSpeed = {x: null, y: null};\r\n\r\n            // Unbind mouse scrolling listener\r\n            off(window, 'wheel', that._manualScroll);\r\n\r\n            // Remove selection-area from dom\r\n            that._clippingElement.remove();\r\n\r\n            // Enable default select event\r\n            off(doc, 'selectstart', preventDefault);\r\n            css(that._area, 'display', 'none');\r\n        },\r\n\r\n        _updatedTouchingElements() {\r\n            const {_selected, _selectables, _area, options} = that;\r\n            const {mode} = options;\r\n            const areaRect = _area.getBoundingClientRect();\r\n\r\n            // Update\r\n            const touched = [];\r\n            const added = [];\r\n            const removed = [];\r\n\r\n            // Itreate over the selectable elements\r\n            for (let i = 0, n = _selectables.length, node; node = _selectables[i], i < n; i++) {\r\n\r\n                // Check if area intersects element\r\n                if (intersects(areaRect, node.getBoundingClientRect(), mode)) {\r\n\r\n                    // Check if the element wasn't present in the last selection.\r\n                    if (!_selected.includes(node)) {\r\n                        added.push(node);\r\n                    }\r\n\r\n                    touched.push(node);\r\n                }\r\n            }\r\n\r\n            // Check which elements where removed since last selection\r\n            for (let i = 0, n = _selected.length, el; el = _selected[i], i < n; i++) {\r\n                if (!touched.includes(el)) {\r\n                    removed.push(el);\r\n                }\r\n            }\r\n\r\n            // Save\r\n            that._selected = touched;\r\n            that._changed = {added, removed};\r\n        },\r\n\r\n        _emit(event, evt) {\r\n            let ok = true;\r\n\r\n            for (const listener of that._eventListener[event]) {\r\n                ok = listener.call(that, {\r\n                    inst: that,\r\n                    area: that._area,\r\n                    selected: that._selected.concat(that._stored),\r\n                    changed: that._changed,\r\n                    oe: evt\r\n                }) && ok;\r\n            }\r\n\r\n            return ok;\r\n        },\r\n\r\n        /**\r\n         * Adds an eventlistener\r\n         * @param event\r\n         * @param cb\r\n         */\r\n        on(event, cb) {\r\n            that._eventListener[event].push(cb);\r\n            return that;\r\n        },\r\n\r\n        /**\r\n         * Removes an event listener\r\n         * @param event\r\n         * @param cb\r\n         */\r\n        off(event, cb) {\r\n            const callBacks = that._eventListener[event];\r\n\r\n            if (callBacks) {\r\n                const index = callBacks.indexOf(cb);\r\n\r\n                if (~index) {\r\n                    callBacks.splice(index, 1);\r\n                }\r\n            }\r\n\r\n            return that;\r\n        },\r\n\r\n        /**\r\n         * Can be used if during a selection elements have been added.\r\n         * Will update everything which can be selected.\r\n         */\r\n        resolveSelectables() {\r\n\r\n            // Resolve selectors\r\n            that._selectables = selectAll(that.options.selectables);\r\n        },\r\n\r\n        /**\r\n         * Saves the current selection for the next selecion.\r\n         * Allows multiple selections.\r\n         */\r\n        keepSelection() {\r\n            const {_selected, _stored} = that;\r\n\r\n            for (let i = 0, n = _selected.length, el; el = _selected[i], i < n; i++) {\r\n                if (!_stored.includes(el)) {\r\n                    _stored.push(el);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Clear the elements which where saved by 'keepSelection()'.\r\n         * @param store If the store should also get cleared\r\n         */\r\n        clearSelection(store = true) {\r\n            store && (that._stored = []);\r\n            that._selected = [];\r\n            that._changed.added = [];\r\n            that._changed.removed = [];\r\n        },\r\n\r\n        /**\r\n         * Removes an particular element from the selection.\r\n         */\r\n        removeFromSelection(el) {\r\n            that._changed.removed.push(el);\r\n            removeElement(that._stored, el);\r\n            removeElement(that._selected, el);\r\n        },\r\n\r\n        /**\r\n         * @returns {Array} Selected elements\r\n         */\r\n        getSelection() {\r\n            return that._stored;\r\n        },\r\n\r\n        /**\r\n         * Cancel the current selection process.\r\n         * @param keepEvent {boolean} true to fire the onStop listener after cancel.\r\n         */\r\n        cancel(keepEvent = false) {\r\n            that._onTapStop(null, !keepEvent);\r\n        },\r\n\r\n        /**\r\n         * Set or get an option.\r\n         * @param   {string} name\r\n         * @param   {*}      value\r\n         * @return  {*}      the new value\r\n         */\r\n        option(name, value) {\r\n            const {options} = that;\r\n            return value === undefined ? options[name] : (options[name] = value);\r\n        },\r\n\r\n        /**\r\n         * Disable the selection functinality.\r\n         */\r\n        disable() {\r\n            that._bindStartEvents('off');\r\n        },\r\n\r\n        /**\r\n         * Unbinds all events and removes the area-element\r\n         */\r\n        destroy() {\r\n            that.disable();\r\n            that._clippingElement.remove();\r\n        },\r\n\r\n        /**\r\n         * Disable the selection functinality.\r\n         */\r\n        enable() {\r\n            that._bindStartEvents('on');\r\n        },\r\n\r\n        /**\r\n         * Manually select elements\r\n         * @param query - CSS Query, can be an array of queries\r\n         */\r\n        select(query) {\r\n            const {_selected, _stored} = that;\r\n            const elements = selectAll(query).filter(el =>\r\n                !_selected.includes(el) &&\r\n                !_stored.includes(el)\r\n            );\r\n\r\n            that._selected.push(...elements);\r\n            that._changed.added.push(...elements);\r\n            return elements;\r\n        }\r\n    };\r\n\r\n    // Initialize\r\n    that._init();\r\n\r\n    return that;\r\n}\r\n\r\n// Export utils\r\nSelection.utils = {\r\n    on,\r\n    off,\r\n    css,\r\n    intersects,\r\n    selectAll,\r\n    eventPath,\r\n    removeElement\r\n};\r\n\r\n/**\r\n * Create selection instance\r\n * @param {Object} [options]\r\n */\r\nSelection.create = options => Selection(options);\r\n\r\n// Set version and export\r\nSelection.version = version;\r\nexport default Selection;\r\n"],"sourceRoot":""}