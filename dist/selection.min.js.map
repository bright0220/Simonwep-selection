{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./src/utils.js","webpack:///./src/selection.js","webpack:///webpack/bootstrap","webpack:///webpack/startup","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand"],"names":["root","factory","exports","module","define","amd","self","eventListener","method","elements","events","fn","options","HTMLCollection","NodeList","Array","from","isArray","element","event","capture","prototype","slice","call","arguments","on","bind","off","unitify","val","unit","css","el","attr","style","key","value","Object","entries","intersects","a","b","mode","bxc","left","width","byc","top","height","right","bottom","Error","selectAll","selector","doc","document","nodes","i","l","length","item","push","querySelectorAll","defaultView","HTMLElement","eventPath","evt","path","composedPath","target","parentElement","window","removeElement","arr","index","indexOf","splice","simplifyEvent","tap","touches","x","clientX","y","clientY","abs","max","min","round","ceil","Math","preventDefault","e","DOMRect","ClientRect","Selection","that","assign","class","frame","tapMode","startThreshold","singleClick","disableTouch","selectables","scrollSpeedDivider","manualScrollSpeed","startareas","boundaries","selectionAreaContainer","_stored","_selectables","_selected","_changed","added","removed","_eventListener","beforestart","start","move","stop","_area","_areaDomRect","_clippingElement","_scrollAvailable","_scrollSpeed","_init","createElement","appendChild","classList","add","willChange","position","overflow","transform","pointerEvents","zIndex","enable","_bindStartEvents","type","_onTapStart","passive","silent","targetBoundingClientRect","getBoundingClientRect","startAreas","_boundaries","_targetContainer","find","evtpath","includes","_emit","_ax1","_ay1","_ax2","_ay2","_singleClick","clearSelection","_delayedTapMove","_onTapStop","_onSingleTap","spl","resolveSelectables","v","stored","shiftKey","reference","preceding","following","compareDocumentPosition","rangeItems","filter","select","removeFromSelection","thresholdType","_onTapMove","tb","_targetBoundary","scrollHeight","scrollWidth","_manualScroll","s","contains","marginTop","marginLeft","scon","ss","_recalcAreaRect","_updatedTouchingElements","_redrawArea","requestAnimationFrame","scroll","scrollY","scrollX","scrollTop","scrollLeft","deltaY","deltaX","clientHeight","clientWidth","brect","x3","y3","x4","y4","areaStyle","noevent","remove","touched","node","ok","listener","inst","area","selected","concat","changed","oe","trigger","cb","callBacks","keepSelection","store","getSelection","cancel","keepEvent","option","name","undefined","disable","destroy","query","quiet","utils","create","version","VERSION","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","obj","prop","hasOwnProperty"],"mappings":"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","file":"selection.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Selection\"] = factory();\n\telse\n\t\troot[\"Selection\"] = factory();\n})(self, function() {\nreturn ","/* eslint-disable prefer-rest-params */\r\nfunction eventListener(method, elements, events, fn, options = {}) {\r\n\r\n    // Normalize array\r\n    if (elements instanceof HTMLCollection || elements instanceof NodeList) {\r\n        elements = Array.from(elements);\r\n    } else if (!Array.isArray(elements)) {\r\n        elements = [elements];\r\n    }\r\n\r\n    if (!Array.isArray(events)) {\r\n        events = [events];\r\n    }\r\n\r\n    for (const element of elements) {\r\n        for (const event of events) {\r\n            element[method](event, fn, {capture: false, ...options});\r\n        }\r\n    }\r\n\r\n    return Array.prototype.slice.call(arguments, 1);\r\n}\r\n\r\n/**\r\n * Add event(s) to element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const on = eventListener.bind(null, 'addEventListener');\r\n\r\n/**\r\n * Remove event(s) from element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const off = eventListener.bind(null, 'removeEventListener');\r\n\r\nconst unitify = (val, unit = 'px') => typeof val === 'number' ? val + unit : val;\r\n\r\n/**\r\n * Add css to a DOM-Element or returns the current\r\n * value of a property.\r\n *\r\n * @param el The Element.\r\n * @param attr The attribute or a object which holds css key-properties.\r\n * @param val The value for a single attribute.\r\n * @returns {*}\r\n */\r\nexport function css(el, attr, val) {\r\n    const style = el && el.style;\r\n    if (style) {\r\n        if (typeof attr === 'object') {\r\n\r\n            for (const [key, value] of Object.entries(attr)) {\r\n                style[key] = unitify(value);\r\n            }\r\n\r\n        } else if (val && typeof attr === 'string') {\r\n            style[attr] = unitify(val);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check if two DOM-Elements intersects each other.\r\n * @param a BoundingClientRect of the first element.\r\n * @param b BoundingClientRect of the second element.\r\n * @param mode Options are center, cover or touch.\r\n * @returns {boolean} If both elements intersects each other.\r\n */\r\nexport function intersects(a, b, mode) {\r\n    switch (mode || 'touch') {\r\n        case 'center': {\r\n            const bxc = b.left + b.width / 2;\r\n            const byc = b.top + b.height / 2;\r\n\r\n            return bxc >= a.left &&\r\n                bxc <= a.right &&\r\n                byc >= a.top &&\r\n                byc <= a.bottom;\r\n        }\r\n        case 'cover': {\r\n            return b.left >= a.left &&\r\n                b.top >= a.top &&\r\n                b.right <= a.right &&\r\n                b.bottom <= a.bottom;\r\n        }\r\n        case 'touch': {\r\n            return a.right >= b.left &&\r\n                a.left <= b.right &&\r\n                a.bottom >= b.top &&\r\n                a.top <= b.bottom;\r\n        }\r\n        default: {\r\n            throw new Error(`Unkown intersection mode: ${mode}`);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Takes a selector (or array of selectors) and returns the matched nodes.\r\n * @param selector The selector or an Array of selectors.\r\n * @returns {Array} Array of DOM-Nodes.\r\n */\r\nexport function selectAll(selector, doc = document) {\r\n    if (!Array.isArray(selector)) {\r\n        selector = [selector];\r\n    }\r\n\r\n    const nodes = [];\r\n    for (let i = 0, l = selector.length; i < l; i++) {\r\n        const item = selector[i];\r\n\r\n        if (typeof item === 'string') {\r\n            nodes.push(...doc.querySelectorAll(item));\r\n        } else if (item instanceof doc.defaultView.HTMLElement) {\r\n            nodes.push(item);\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\n/**\r\n * Polyfill for safari & firefox for the eventPath event property.\r\n * @param evt The event object.\r\n * @return [String] event path.\r\n */\r\nexport function eventPath(evt) {\r\n    let path = evt.path || (evt.composedPath && evt.composedPath());\r\n\r\n    if (path && path.length > 0) {\r\n        return path;\r\n    }\r\n\r\n    let el = evt.target;\r\n    for (path = [el]; (el = el.parentElement);) {\r\n        path.push(el);\r\n    }\r\n\r\n    path.push(document, window);\r\n    return path;\r\n}\r\n\r\n/**\r\n * Removes an element from an Array.\r\n */\r\nexport function removeElement(arr, el) {\r\n    const index = arr.indexOf(el);\r\n\r\n    if (~index) {\r\n        arr.splice(index, 1);\r\n    }\r\n}\r\n\r\nexport function simplifyEvent(evt) {\r\n    const tap = (evt.touches && evt.touches[0] || evt);\r\n    return {\r\n        tap,\r\n        x: tap.clientX,\r\n        y: tap.clientY,\r\n        target: tap.target\r\n    };\r\n}\r\n","import {css, eventPath, intersects, off, on, removeElement, selectAll, simplifyEvent} from './utils';\r\n\r\n// Some var shorting for better compression and readability\r\nconst {abs, max, min, round, ceil} = Math;\r\nconst preventDefault = e => e.preventDefault();\r\n\r\n// Edge < 79 uses the unofficial name ClienRect\r\nconst DOMRect = typeof window.DOMRect === 'undefined' ? window.ClientRect : window.DOMRect;\r\n\r\n/* eslint-disable new-cap */\r\nfunction Selection(options = {}) {\r\n\r\n    const that = {\r\n\r\n        options: Object.assign({\r\n            class: 'selection-area',\r\n            frame: document,\r\n            mode: 'touch',\r\n            tapMode: 'native',\r\n            startThreshold: 10,\r\n            singleClick: true,\r\n            disableTouch: false,\r\n\r\n            selectables: [],\r\n            scrollSpeedDivider: 10,\r\n            manualScrollSpeed: 750,\r\n\r\n            startareas: ['html'],\r\n            boundaries: ['html'],\r\n            selectionAreaContainer: 'body'\r\n        }, options),\r\n\r\n        // Store for keepSelection\r\n        _stored: [],\r\n        _selectables: [],\r\n        _selected: [], // Currently touched elements\r\n        _changed: {\r\n            added: [], // Added elements since last selection\r\n            removed: [] // Removed elements since last selection\r\n        },\r\n\r\n        // Evenlistener name: [callbacks]\r\n        _eventListener: {\r\n            beforestart: [],\r\n            start: [],\r\n            move: [],\r\n            stop: []\r\n        },\r\n\r\n        // Create area element\r\n        _area: null,\r\n        _areaDomRect: null, // Caches the position of the selection-area\r\n        _clippingElement: null,\r\n\r\n        // Is getting set on movement. Varied.\r\n        _scrollAvailable: true,\r\n        _scrollSpeed: {x: null, y: null},\r\n\r\n        _init() {\r\n            const {frame} = that.options;\r\n            that._area = frame.createElement('div');\r\n            that._clippingElement = frame.createElement('div');\r\n            that._clippingElement.appendChild(that._area);\r\n\r\n            // Add class to the area element\r\n            that._area.classList.add(that.options.class);\r\n\r\n            // Apply basic styles to the area element\r\n            css(that._area, {\r\n                willChange: 'top, left, bottom, right, width, height',\r\n                top: 0,\r\n                left: 0,\r\n                position: 'fixed'\r\n            });\r\n\r\n            css(that._clippingElement, {\r\n                overflow: 'hidden',\r\n                position: 'fixed',\r\n                transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\r\n                pointerEvents: 'none',\r\n                zIndex: '1'\r\n            });\r\n\r\n            that.enable();\r\n        },\r\n\r\n        _bindStartEvents(type) {\r\n            const {frame} = that.options;\r\n            const fn = type === 'on' ? on : off;\r\n            fn(frame, 'mousedown', that._onTapStart);\r\n\r\n            if (!that.options.disableTouch) {\r\n                fn(frame, 'touchstart', that._onTapStart, {\r\n                    passive: false\r\n                });\r\n            }\r\n        },\r\n\r\n        _onTapStart(evt, silent = false) {\r\n            const {x, y, target} = simplifyEvent(evt);\r\n            const {startareas, boundaries, frame} = that.options;\r\n            const targetBoundingClientRect = target.getBoundingClientRect();\r\n\r\n            // Find start-areas and boundaries\r\n            const startAreas = selectAll(startareas, frame);\r\n            that._boundaries = selectAll(boundaries, frame);\r\n\r\n            // Check in which container the user currently acts\r\n            that._targetContainer = that._boundaries.find(el =>\r\n                intersects(el.getBoundingClientRect(), targetBoundingClientRect)\r\n            );\r\n\r\n            // Check if area starts in one of the start areas / boundaries\r\n            const evtpath = eventPath(evt);\r\n            if (!that._targetContainer ||\r\n                !startAreas.find(el => evtpath.includes(el)) ||\r\n                !that._boundaries.find(el => evtpath.includes(el))) {\r\n                return;\r\n            }\r\n\r\n            if (!silent && that._emit('beforestart', evt) === false) {\r\n                return;\r\n            }\r\n\r\n            // Area start point\r\n            that._ax1 = x;\r\n            that._ay1 = y;\r\n\r\n            // Area end point\r\n            that._ax2 = 0;\r\n            that._ay2 = 0;\r\n\r\n            // To detect single-click\r\n            that._singleClick = true;\r\n            that.clearSelection(false);\r\n\r\n            // Prevent default select event\r\n            on(frame, 'selectstart', preventDefault);\r\n\r\n            // Add listener\r\n            on(frame, ['touchmove', 'mousemove'], that._delayedTapMove, {passive: false});\r\n            on(frame, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\r\n\r\n            // Firefox will scroll down the page which would break the selection.\r\n            evt.preventDefault();\r\n        },\r\n\r\n        _onSingleTap(evt) {\r\n            const {tapMode} = that.options;\r\n            const spl = simplifyEvent(evt);\r\n            let target = null;\r\n\r\n            if (tapMode === 'native') {\r\n                target = spl.target;\r\n            } else if (tapMode === 'touch') {\r\n                that.resolveSelectables();\r\n\r\n                const {x, y} = spl;\r\n                target = that._selectables.find(v => {\r\n                    const {right, left, top, bottom} = v.getBoundingClientRect();\r\n                    return x < right && x > left && y < bottom && y > top;\r\n                });\r\n            } else {\r\n                throw new Error(`Unknown tapMode option: ${tapMode}`);\r\n            }\r\n\r\n            if (!target) {\r\n                return false;\r\n            }\r\n\r\n            /**\r\n             * Resolve selectables again.\r\n             * If the user starded in a scrollable area they will be reduced\r\n             * to the current area. Prevent the exclusion of these if a range-selection\r\n             * gets performed.\r\n             */\r\n            that.resolveSelectables();\r\n\r\n            // Traverse dom upwards to check if target is selectable\r\n            while (!that._selectables.includes(target)) {\r\n                if (!target.parentElement) {\r\n                    return;\r\n                }\r\n\r\n                target = target.parentElement;\r\n            }\r\n\r\n            that._emit('start', evt);\r\n            const stored = that._stored;\r\n            if (evt.shiftKey && stored.length) {\r\n                const reference = stored[stored.length - 1];\r\n\r\n                // Resolve correct range\r\n                const [preceding, following] = reference.compareDocumentPosition(target) & 4 ? [target, reference] : [reference, target];\r\n\r\n                const rangeItems = [...that._selectables.filter(el =>\r\n                    (el.compareDocumentPosition(preceding) & 4) &&\r\n                    (el.compareDocumentPosition(following) & 2)\r\n                ), target];\r\n\r\n                that.select(rangeItems);\r\n                that._emit('move', evt);\r\n                that._emit('stop', evt);\r\n            } else {\r\n\r\n                if (that._stored.includes(target)) {\r\n                    that.removeFromSelection(target);\r\n                } else {\r\n                    that.select(target);\r\n                }\r\n\r\n                that._emit('move', evt);\r\n                that._emit('stop', evt);\r\n            }\r\n        },\r\n\r\n        _delayedTapMove(evt) {\r\n            const {x, y} = simplifyEvent(evt);\r\n            const {startThreshold, frame} = that.options;\r\n            const {_ax1, _ay1} = that; // Coordinates of first \"tap\"\r\n\r\n            // Check pixel threshold\r\n            const thresholdType = typeof startThreshold;\r\n            if ((thresholdType === 'number' && abs((x + y) - (_ax1 + _ay1)) >= startThreshold) ||\r\n                (thresholdType === 'object' && abs(x - _ax1) >= startThreshold.x || abs(y - _ay1) >= startThreshold.y)) {\r\n                off(frame, ['mousemove', 'touchmove'], that._delayedTapMove, {passive: false});\r\n                on(frame, ['mousemove', 'touchmove'], that._onTapMove, {passive: false});\r\n\r\n                // Make area element visible\r\n                css(that._area, 'display', 'block');\r\n\r\n                // Apppend selection-area to the dom\r\n                selectAll(that.options.selectionAreaContainer, frame)[0].appendChild(that._clippingElement);\r\n\r\n                // Now after the threshold is reached resolve all selectables\r\n                that.resolveSelectables();\r\n\r\n                // An action is recognized as single-select until the user performed a mutli-selection\r\n                that._singleClick = false;\r\n\r\n                // Just saving the boundaries of this container for later\r\n                const tb = that._targetBoundary = that._targetContainer.getBoundingClientRect();\r\n\r\n                // Find container and check if it's scrollable\r\n                if (round(that._targetContainer.scrollHeight) !== round(tb.height) ||\r\n                    round(that._targetContainer.scrollWidth) !== round(tb.width)) {\r\n\r\n                    // Indenticates if the user is currently in a scrollable area\r\n                    that._scrollAvailable = true;\r\n\r\n                    // Detect mouse scrolling\r\n                    on(window, 'wheel', that._manualScroll, {passive: false});\r\n\r\n                    /**\r\n                     * The selection-area will also cover other element which are\r\n                     * out of the current scrollable parent. So find all elements\r\n                     * which are in the current scrollable element. Later these are\r\n                     * the only selectables instead of all.\r\n                     */\r\n                    that._selectables = that._selectables.filter(s => that._targetContainer.contains(s));\r\n\r\n                    /**\r\n                     * To clip the area, the selection area has a parent\r\n                     * which has exact the same dimensions as the scrollable elemeent.\r\n                     * Now if the area exeeds these boundaries it will be cropped.\r\n                     */\r\n                    css(that._clippingElement, {\r\n                        top: tb.top,\r\n                        left: tb.left,\r\n                        width: tb.width,\r\n                        height: tb.height\r\n                    });\r\n\r\n                    /**\r\n                     * The area element is relative to the clipping element,\r\n                     * but when this is moved or transformed we need to correct\r\n                     * the positions via a negative margin.\r\n                     */\r\n                    css(that._area, {\r\n                        marginTop: -tb.top,\r\n                        marginLeft: -tb.left\r\n                    });\r\n                } else {\r\n                    that._scrollAvailable = false;\r\n\r\n                    /**\r\n                     * Reset margin and clipping element dimensions.\r\n                     */\r\n                    css(that._clippingElement, {\r\n                        top: 0,\r\n                        left: 0,\r\n                        width: '100%',\r\n                        height: '100%'\r\n                    });\r\n\r\n                    css(that._area, {\r\n                        marginTop: 0,\r\n                        marginLeft: 0\r\n                    });\r\n                }\r\n\r\n                // Trigger recalc and fire event\r\n                that._onTapMove(evt);\r\n                that._emit('start', evt);\r\n            }\r\n\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        },\r\n\r\n        _onTapMove(evt) {\r\n            const {x, y} = simplifyEvent(evt);\r\n            const {scrollSpeedDivider} = that.options;\r\n            const scon = that._targetContainer;\r\n            let ss = that._scrollSpeed;\r\n            that._ax2 = x;\r\n            that._ay2 = y;\r\n\r\n            if (that._scrollAvailable && (ss.y !== null || ss.x !== null)) {\r\n\r\n                // Continous scrolling\r\n                requestAnimationFrame(function scroll() {\r\n\r\n                    // Make sure that ss is not outdated\r\n                    ss = that._scrollSpeed;\r\n                    const scrollY = ss.y !== null;\r\n                    const scrollX = ss.x !== null;\r\n\r\n                    // Scrolling is not anymore required\r\n                    if (!scrollY && !scrollX) {\r\n                        return;\r\n                    }\r\n\r\n                    /**\r\n                     * If the value exeeds the scrollable area it will\r\n                     * be set to the max / min value. So change only\r\n                     */\r\n                    const {scrollTop, scrollLeft} = scon;\r\n\r\n                    // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\r\n                    if (scrollY) {\r\n                        scon.scrollTop += ceil(ss.y / scrollSpeedDivider);\r\n                        that._ay1 -= scon.scrollTop - scrollTop;\r\n                    }\r\n\r\n                    if (scrollX) {\r\n                        scon.scrollLeft += ceil(ss.x / scrollSpeedDivider);\r\n                        that._ax1 -= scon.scrollLeft - scrollLeft;\r\n                    }\r\n\r\n                    /**\r\n                     * We changed the start coordinates -> redraw the selectiona area\r\n                     * We changed the dimensions of the area element -> re-calc selected elements\r\n                     * The selected elements array has been changed -> fire event\r\n                     */\r\n                    that._recalcAreaRect();\r\n                    that._updatedTouchingElements();\r\n                    that._emit('move', evt);\r\n                    that._redrawArea();\r\n\r\n                    // Keep scrolling even if the user stops to move his pointer\r\n                    requestAnimationFrame(scroll);\r\n                });\r\n            } else {\r\n\r\n                /**\r\n                 * Perform redraw only if scrolling is not active.\r\n                 * If scrolling is active this area is getting re-dragwed by the\r\n                 * anonymized scroll function.\r\n                 */\r\n                that._recalcAreaRect();\r\n                that._updatedTouchingElements();\r\n                that._emit('move', evt);\r\n                that._redrawArea();\r\n            }\r\n\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        },\r\n\r\n        _manualScroll(evt) {\r\n            const {manualScrollSpeed} = that.options;\r\n\r\n            // Consistent scrolling speed on all browsers\r\n            const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\r\n            const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\r\n            that._scrollSpeed.y += deltaY * manualScrollSpeed;\r\n            that._scrollSpeed.x += deltaX * manualScrollSpeed;\r\n            that._onTapMove(evt);\r\n\r\n            // Prevent defaul scrolling behaviour, eg. page scrolling\r\n            evt.preventDefault();\r\n        },\r\n\r\n        _recalcAreaRect() {\r\n            const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = that._targetContainer;\r\n            const brect = that._targetBoundary;\r\n            const ss = that._scrollSpeed;\r\n            let x = that._ax2;\r\n            let y = that._ay2;\r\n\r\n            if (x < brect.left) {\r\n                ss.x = scrollLeft ? -abs(brect.left - x) : null;\r\n                x = brect.left;\r\n            } else if (x > brect.left + brect.width) {\r\n                ss.x = scrollWidth - scrollLeft - clientWidth ? abs(brect.left + brect.width - x) : null;\r\n                x = brect.left + brect.width;\r\n            } else {\r\n                ss.x = null;\r\n            }\r\n\r\n            if (y < brect.top) {\r\n                ss.y = scrollTop ? -abs(brect.top - y) : null;\r\n                y = brect.top;\r\n            } else if (y > brect.top + brect.height) {\r\n                ss.y = scrollHeight - scrollTop - clientHeight ? abs(brect.top + brect.height - y) : null;\r\n                y = brect.top + brect.height;\r\n            } else {\r\n                ss.y = null;\r\n            }\r\n\r\n            const x3 = min(that._ax1, x);\r\n            const y3 = min(that._ay1, y);\r\n            const x4 = max(that._ax1, x);\r\n            const y4 = max(that._ay1, y);\r\n            that._areaDomRect = new DOMRect(x3, y3, x4 - x3, y4 - y3);\r\n        },\r\n\r\n        _redrawArea() {\r\n            const {x, y, width, height} = that._areaDomRect;\r\n            const areaStyle = that._area.style;\r\n\r\n            // It's generally faster to not use es6-templates\r\n            // It's also faster to manually change the properties instead of calling Object.assign\r\n            /* eslint prefer-template: \"off\" */\r\n            areaStyle.transform = 'translate3d(' + x + 'px,' + y + 'px, 0)';\r\n            areaStyle.width = width + 'px';\r\n            areaStyle.height = height + 'px';\r\n        },\r\n\r\n        _onTapStop(evt, noevent) {\r\n            const {frame, singleClick} = that.options;\r\n\r\n            // Remove event handlers\r\n            off(frame, ['mousemove', 'touchmove'], that._delayedTapMove);\r\n            off(frame, ['touchmove', 'mousemove'], that._onTapMove);\r\n            off(frame, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\r\n\r\n            if (evt && that._singleClick && singleClick) {\r\n                that._onSingleTap(evt);\r\n            } else if (!that._singleClick && !noevent) {\r\n                that._updatedTouchingElements();\r\n                that._emit('stop', evt);\r\n            }\r\n\r\n            // Reset scroll speed\r\n            that._scrollSpeed = {x: null, y: null};\r\n\r\n            // Unbind mouse scrolling listener\r\n            off(window, 'wheel', that._manualScroll);\r\n\r\n            // Remove selection-area from dom\r\n            that._clippingElement.remove();\r\n\r\n            // Enable default select event\r\n            off(frame, 'selectstart', preventDefault);\r\n            css(that._area, 'display', 'none');\r\n        },\r\n\r\n        _updatedTouchingElements() {\r\n            const {_selected, _selectables, options, _areaDomRect} = that;\r\n            const {mode} = options;\r\n\r\n            // Update\r\n            const touched = [];\r\n            const added = [];\r\n            const removed = [];\r\n\r\n            // Itreate over the selectable elements\r\n            for (let i = 0; i < _selectables.length; i++) {\r\n                const node = _selectables[i];\r\n\r\n                // Check if area intersects element\r\n                if (intersects(_areaDomRect, node.getBoundingClientRect(), mode)) {\r\n\r\n                    // Check if the element wasn't present in the last selection.\r\n                    if (!_selected.includes(node)) {\r\n                        added.push(node);\r\n                    }\r\n\r\n                    touched.push(node);\r\n                }\r\n            }\r\n\r\n            // Check which elements where removed since last selection\r\n            for (let i = 0; i < _selected.length; i++) {\r\n                const el = _selected[i];\r\n                if (!touched.includes(el)) {\r\n                    removed.push(el);\r\n                }\r\n            }\r\n\r\n            // Save\r\n            that._selected = touched;\r\n            that._changed = {added, removed};\r\n        },\r\n\r\n        _emit(event, evt) {\r\n            let ok = true;\r\n\r\n            for (const listener of that._eventListener[event]) {\r\n                ok = listener.call(that, {\r\n                    inst: that,\r\n                    area: that._area,\r\n                    selected: that._selected.concat(that._stored),\r\n                    changed: that._changed,\r\n                    oe: evt\r\n                }) && ok;\r\n            }\r\n\r\n            return ok;\r\n        },\r\n\r\n        /**\r\n         * Manually triggers the start of a selection\r\n         * @param evt A MouseEvent / TouchEvent -like object\r\n         * @param silent If beforestart should be fired,\r\n         */\r\n        trigger(evt, silent = true) {\r\n            that._onTapStart(evt, silent);\r\n        },\r\n\r\n        /**\r\n         * Adds an eventlistener\r\n         * @param event\r\n         * @param cb\r\n         */\r\n        on(event, cb) {\r\n            that._eventListener[event].push(cb);\r\n            return that;\r\n        },\r\n\r\n        /**\r\n         * Removes an event listener\r\n         * @param event\r\n         * @param cb\r\n         */\r\n        off(event, cb) {\r\n            const callBacks = that._eventListener[event];\r\n\r\n            if (callBacks) {\r\n                const index = callBacks.indexOf(cb);\r\n\r\n                if (~index) {\r\n                    callBacks.splice(index, 1);\r\n                }\r\n            }\r\n\r\n            return that;\r\n        },\r\n\r\n        /**\r\n         * Can be used if during a selection elements have been added.\r\n         * Will update everything which can be selected.\r\n         */\r\n        resolveSelectables() {\r\n\r\n            // Resolve selectors\r\n            that._selectables = selectAll(that.options.selectables, that.options.frame);\r\n        },\r\n\r\n        /**\r\n         * Saves the current selection for the next selecion.\r\n         * Allows multiple selections.\r\n         */\r\n        keepSelection() {\r\n            const {_selected, _stored} = that;\r\n\r\n            for (let i = 0; i < _selected.length; i++) {\r\n                const el = _selected[i];\r\n                if (!_stored.includes(el)) {\r\n                    _stored.push(el);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Clear the elements which where saved by 'keepSelection()'.\r\n         * @param store If the store should also get cleared\r\n         */\r\n        clearSelection(store = true) {\r\n            store && (that._stored = []);\r\n            that._selected = [];\r\n            that._changed.added = [];\r\n            that._changed.removed = [];\r\n        },\r\n\r\n        /**\r\n         * Removes an particular element from the selection.\r\n         */\r\n        removeFromSelection(el) {\r\n            that._changed.removed.push(el);\r\n            removeElement(that._stored, el);\r\n            removeElement(that._selected, el);\r\n        },\r\n\r\n        /**\r\n         * @returns {Array} Selected elements\r\n         */\r\n        getSelection() {\r\n            return that._stored;\r\n        },\r\n\r\n        /**\r\n         * Cancel the current selection process.\r\n         * @param keepEvent {boolean} true to fire the onStop listener after cancel.\r\n         */\r\n        cancel(keepEvent = false) {\r\n            that._onTapStop(null, !keepEvent);\r\n        },\r\n\r\n        /**\r\n         * Set or get an option.\r\n         * @param   {string} name\r\n         * @param   {*}      value\r\n         * @return  {*}      the new value\r\n         */\r\n        option(name, value) {\r\n            const {options} = that;\r\n            return value === undefined ? options[name] : (options[name] = value);\r\n        },\r\n\r\n        /**\r\n         * Disable the selection functinality.\r\n         */\r\n        disable() {\r\n            that._bindStartEvents('off');\r\n        },\r\n\r\n        /**\r\n         * Unbinds all events and removes the area-element\r\n         */\r\n        destroy() {\r\n            that.disable();\r\n            that._clippingElement.remove();\r\n        },\r\n\r\n        /**\r\n         * Disable the selection functinality.\r\n         */\r\n        enable() {\r\n            that._bindStartEvents('on');\r\n        },\r\n\r\n        /**\r\n         * Manually select elements\r\n         * @param query - CSS Query, can be an array of queries\r\n         * @param quiet - If this should not trigger the move event\r\n         */\r\n        select(query, quiet = false) {\r\n            const {_changed, _selected, _stored, options} = that;\r\n            const elements = selectAll(query, options.frame).filter(el =>\r\n                !_selected.includes(el) &&\r\n                !_stored.includes(el)\r\n            );\r\n\r\n            // Update stores\r\n            _selected.push(...elements);\r\n            _changed.added.push(...elements);\r\n\r\n            // Fire event\r\n            that._emit('move', null);\r\n            return elements;\r\n        }\r\n    };\r\n\r\n    // Initialize\r\n    that._init();\r\n\r\n    return that;\r\n}\r\n\r\n// Export utils\r\nSelection.utils = {\r\n    on,\r\n    off,\r\n    css,\r\n    intersects,\r\n    selectAll,\r\n    eventPath,\r\n    removeElement\r\n};\r\n\r\n/**\r\n * Create selection instance\r\n * @param {Object} [options]\r\n */\r\nSelection.create = options => Selection(options);\r\n\r\n// Set version and export\r\nSelection.version = VERSION;\r\nexport default Selection;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(380);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)"],"sourceRoot":""}