{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/utils.js","webpack:///./src/selection.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","eventListener","method","elements","events","fn","options","HTMLCollection","NodeList","Array","from","isArray","element","event","_objectSpread","capture","slice","arguments","on","off","unitify","val","unit","css","el","attr","style","prop","dw","document","defaultView","getComputedStyle","currentStyle","intersects","a","b","bxc","left","width","byc","top","height","right","bottom","selectAll","selector","nodes","length","item","push","querySelectorAll","HTMLElement","eventPath","evt","path","composedPath","target","parentElement","removeElement","arr","index","indexOf","splice","simplifyEvent","tap","touches","x","clientX","y","clientY","abs","max","min","round","ceil","Math","doc","preventDefault","e","Selection","that","assign","class","startThreshold","singleClick","disableTouch","validateStart","selectables","scrollSpeedDivider","startareas","boundaries","selectionAreaContainer","_selectedStore","_touchedElements","_changedElements","added","removed","_areaElement","createElement","_clippingElement","_scrollAvailable","_scrollSpeed","_init","appendChild","willChange","position","overflow","transform","pointerEvents","zIndex","enable","_bindStartEvents","type","_onTapStart","passive","targetBoundingClientRect","getBoundingClientRect","startAreas","_boundaries","evtpath","find","includes","_areaX1","_areaY1","_areaX2","_areaY2","_singleClick","_targetContainer","resolveSelectables","tb","_targetBoundary","scrollHeight","scrollWidth","_manualScroll","_selectables","filter","contains","marginTop","marginLeft","margin-top","margin-left","classList","add","_delayedTapMove","_onTapStop","_onSingleTap","stored","shiftKey","reference","preceding","following","compareDocumentPosition","rangeItems","select","_dispatchEvent","_onTapMove","scon","ss","_redrawArea","_updatedTouchingElements","requestAnimationFrame","scroll","scrollTop","scrollLeft","wheelDeltaY","wheelDeltaX","clientHeight","clientWidth","brect","x3","y3","x4","y4","concat","noevent","remove","filterEvent","selectionFilter","filterEventOk","areaRect","touched","node","selection","eventName","originalEvent","additional","selection_objectSpread","areaElement","selectedElements","changedElements","keepSelection","clearSelection","removeFromSelection","getSelection","cancel","keepEvent","option","disable","destroy","query","this","utils","version"],"mappings":"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","file":"selection.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Selection\"] = factory();\n\telse\n\t\troot[\"Selection\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","function eventListener(method, elements, events, fn, options = {}) {\r\n\r\n    // Normalize array\r\n    if (elements instanceof HTMLCollection || elements instanceof NodeList) {\r\n        elements = Array.from(elements);\r\n    } else if (!Array.isArray(elements)) {\r\n        elements = [elements];\r\n    }\r\n\r\n    if (!Array.isArray(events)) events = [events];\r\n\r\n    for (const element of elements) {\r\n        for (const event of events) {\r\n            element[method](event, fn, {capture: false, ...options});\r\n        }\r\n    }\r\n\r\n    return Array.prototype.slice.call(arguments, 1);\r\n}\r\n\r\n/**\r\n * Add event(s) to element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const on = eventListener.bind(null, 'addEventListener');\r\n\r\n/**\r\n * Remove event(s) from element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const off = eventListener.bind(null, 'removeEventListener');\r\n\r\nconst unitify = (val, unit = 'px') => typeof val === 'number' ? val + unit :  val;\r\n\r\n/**\r\n * Add css to a DOM-Element or returns the current\r\n * value of a property.\r\n *\r\n * @param el The Element.\r\n * @param attr The attribute or a object which holds css key-properties.\r\n * @param val The value for a single attribute.\r\n * @returns {*}\r\n */\r\nexport function css(el, attr, val) {\r\n    const style = el && el.style;\r\n    if (!style) return;\r\n\r\n    if (typeof attr === 'object') {\r\n\r\n        for (const prop in attr) {\r\n            style[prop] = unitify(attr[prop]);\r\n        }\r\n\r\n    } else if (val === null) {\r\n\r\n        const dw = document.defaultView;\r\n        if (dw && dw.getComputedStyle) {\r\n            val = dw.getComputedStyle(el, null);\r\n        } else if (el.currentStyle) {\r\n            val = el.currentStyle;\r\n        }\r\n\r\n        return attr === null ? val : val[attr];\r\n    } else {\r\n        style[attr] = unitify(val);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if two DOM-Elements intersects each other.\r\n * @param a BoundingClientRect of the first element.\r\n * @param b BoundingClientRect of the second element.\r\n * @param mode Options are center, cover or touch.\r\n * @returns {boolean} If both elements intersects each other.\r\n */\r\nexport function intersects(a, b, mode) {\r\n    switch (mode || 'touch') {\r\n        case 'center': {\r\n            const bxc = b.left + b.width / 2;\r\n            const byc = b.top + b.height / 2;\r\n\r\n            return bxc >= a.left\r\n                && bxc <= a.right\r\n                && byc >= a.top\r\n                && byc <= a.bottom;\r\n        }\r\n        case 'cover': {\r\n            return b.left >= a.left\r\n                && b.top >= a.top\r\n                && b.right <= a.right\r\n                && b.bottom <= a.bottom;\r\n        }\r\n        case 'touch': {\r\n            return a.right >= b.left\r\n                && a.left <= b.right\r\n                && a.bottom >= b.top\r\n                && a.top <= b.bottom;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Takes a selector (or array of selectors) and returns the matched nodes.\r\n * @param selector The selector or an Array of selectors.\r\n * @returns {Array} Array of DOM-Nodes.\r\n */\r\nexport function selectAll(selector) {\r\n    if (!Array.isArray(selector)) {\r\n        selector = [selector];\r\n    }\r\n\r\n    const nodes = [];\r\n    for (let i = 0, l = selector.length; i < l; i++) {\r\n        const item = selector[i];\r\n\r\n        if (typeof item === 'string') {\r\n            nodes.push(...document.querySelectorAll(item));\r\n        } else if (item instanceof HTMLElement) {\r\n            nodes.push(item);\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\n/**\r\n * Polyfill for safari & firefox for the eventPath event property.\r\n * @param evt The event object.\r\n * @return [String] event path.\r\n */\r\nexport function eventPath(evt) {\r\n    let path = evt.path || (evt.composedPath && evt.composedPath());\r\n    if (path) return path;\r\n\r\n    let el = evt.target.parentElement;\r\n    path = [evt.target, el];\r\n    while (el = el.parentElement) path.push(el);\r\n\r\n    path.push(document, window);\r\n    return path;\r\n}\r\n\r\n/**\r\n * Removes an element from an Array.\r\n */\r\nexport function removeElement(arr, el) {\r\n    const index = arr.indexOf(el);\r\n    if (~index) arr.splice(index, 1);\r\n}\r\n\r\nexport function simplifyEvent(evt) {\r\n    const tap = (evt.touches && evt.touches[0] || evt);\r\n    return {\r\n        tap,\r\n        x: tap.clientX,\r\n        y: tap.clientY,\r\n        target: tap.target\r\n    };\r\n}\r\n","import {on, off, css, selectAll, eventPath, intersects, simplifyEvent, removeElement} from './utils';\r\n\r\n// Some var shorting for better compression and readability\r\nconst {abs, max, min, round, ceil} = Math;\r\nconst doc = document;\r\nconst preventDefault = e => e.preventDefault();\r\n\r\nfunction Selection(options = {}) {\r\n\r\n    const that = {\r\n\r\n        options: Object.assign({\r\n            class: 'selection-area',\r\n\r\n            mode: 'touch',\r\n            startThreshold: 10,\r\n            singleClick: true,\r\n            disableTouch: false,\r\n\r\n            validateStart: () => true,\r\n\r\n            selectables: [],\r\n\r\n            scrollSpeedDivider: 10,\r\n\r\n            startareas: ['html'],\r\n            boundaries: ['html'],\r\n\r\n            selectionAreaContainer: 'body'\r\n        }, options),\r\n\r\n        // Store for keepSelection\r\n        _selectedStore: [],\r\n        _touchedElements: [], // Currently touched elements\r\n        _changedElements: {\r\n            added: [],  // Added elements since last selection\r\n            removed: [] // Removed elements since last selection\r\n        },\r\n\r\n        // Create area element\r\n        _areaElement: doc.createElement('div'),\r\n        _clippingElement: doc.createElement('div'),\r\n\r\n        // Is getting set on movement. Varied.\r\n        _scrollAvailable: true,\r\n        _scrollSpeed: {x: null, y: null},\r\n\r\n        _init() {\r\n            that._clippingElement.appendChild(that._areaElement);\r\n\r\n            // Apply basic styles to the area element\r\n            css(that._areaElement, {\r\n                willChange: 'top, left, bottom, right, width, height',\r\n                top: 0,\r\n                left: 0,\r\n                position: 'fixed'\r\n            });\r\n\r\n            css(that._clippingElement, {\r\n                overflow: 'hidden',\r\n                position: 'fixed',\r\n                transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\r\n                pointerEvents: 'none',\r\n                zIndex: 1\r\n            });\r\n\r\n            that.enable();\r\n        },\r\n\r\n        _bindStartEvents(type) {\r\n            const fn = type === 'on' ? on : off;\r\n            fn(doc, 'mousedown', that._onTapStart);\r\n\r\n            if (!that.options.disableTouch) {\r\n                fn(doc, 'touchstart', that._onTapStart, {\r\n                    passive: false\r\n                });\r\n            }\r\n        },\r\n\r\n        _onTapStart(evt) {\r\n            const {x, y, target} = simplifyEvent(evt);\r\n            const targetBoundingClientRect = target.getBoundingClientRect();\r\n\r\n            // Apppend selection-area to the dom\r\n            selectAll(that.options.selectionAreaContainer)[0].appendChild(that._clippingElement);\r\n\r\n            // Check mouse middleware\r\n            if (!that.options.validateStart(evt)) {\r\n                return;\r\n            }\r\n\r\n            // Find start-areas and boundaries\r\n            const startAreas = selectAll(that.options.startareas);\r\n            that._boundaries = selectAll(that.options.boundaries);\r\n\r\n            // Check if area starts in one of the start areas / boundaries\r\n            const evtpath = eventPath(evt);\r\n            if (!startAreas.find(el => evtpath.includes(el)) ||\r\n                !that._boundaries.find(el => evtpath.includes(el))) {\r\n                return;\r\n            }\r\n\r\n            // Area start point\r\n            that._areaX1 = x;\r\n            that._areaY1 = y;\r\n\r\n            // Area end point\r\n            that._areaX2 = 0;\r\n            that._areaY2 = 0;\r\n\r\n            that._singleClick = true; // To detect single-click\r\n\r\n            // Check in which container the user currently acts\r\n            that._targetContainer = that._boundaries.find(el =>\r\n                intersects(el.getBoundingClientRect(), targetBoundingClientRect)\r\n            );\r\n\r\n            if (!that._targetContainer) {\r\n                return;\r\n            }\r\n\r\n            that.resolveSelectables();\r\n\r\n            // Just saving the boundaries of this container for later\r\n            const tb = that._targetBoundary = that._targetContainer.getBoundingClientRect();\r\n            that._touchedElements = [];\r\n            that._changedElements = {\r\n                added: [],\r\n                removed: []\r\n            };\r\n\r\n            // Find container and check if it's scrollable\r\n            if (round(that._targetContainer.scrollHeight) !== round(tb.height) ||\r\n                round(that._targetContainer.scrollWidth) !== round(tb.width)) {\r\n\r\n                // Indenticates if the user is currently in a scrollable area\r\n                that._scrollAvailable = true;\r\n\r\n                // Detect mouse scrolling\r\n                on(window, 'wheel', that._manualScroll, {passive: false});\r\n\r\n                /**\r\n                 * The selection-area will also cover other element which are\r\n                 * out of the current scrollable parent. So find all elements\r\n                 * which are in the current scrollable element. Later these are\r\n                 * the only selectables instead of all.\r\n                 */\r\n                that._selectables = that._selectables.filter(s => that._targetContainer.contains(s));\r\n\r\n                /**\r\n                 * To clip the area, the selection area has a parent\r\n                 * which has exact the same dimensions as the scrollable elemeent.\r\n                 * Now if the area exeeds these boundaries it will be cropped.\r\n                 */\r\n                css(that._clippingElement, {\r\n                    top: tb.top,\r\n                    left: tb.left,\r\n                    width: tb.width,\r\n                    height: tb.height\r\n                });\r\n\r\n                /**\r\n                 * The area element is relative to the clipping element,\r\n                 * but when this is moved or transformed we need to correct\r\n                 * the positions via a negative margin.\r\n                 */\r\n                css(that._areaElement, {\r\n                    marginTop: -tb.top,\r\n                    marginLeft: -tb.left\r\n                });\r\n            } else {\r\n                that._scrollAvailable = false;\r\n\r\n                /**\r\n                 * Reset margin and clipping element dimensions.\r\n                 */\r\n                css(that._clippingElement, {\r\n                    top: 0,\r\n                    left: 0,\r\n                    width: '100%',\r\n                    height: '100%'\r\n                });\r\n\r\n                css(that._areaElement, {\r\n                    'margin-top': 0,\r\n                    'margin-left': 0\r\n                });\r\n            }\r\n\r\n            // Add class to the area element\r\n            that._areaElement.classList.add(that.options.class);\r\n\r\n            // Prevent default select event\r\n            on(doc, 'selectstart', preventDefault);\r\n\r\n            // Add listener\r\n            on(doc, ['touchmove', 'mousemove'], that._delayedTapMove, {passive: false});\r\n            on(doc, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\r\n        },\r\n\r\n        _onSingleTap(evt) {\r\n            let {target} = simplifyEvent(evt);\r\n\r\n            /**\r\n             * Resolve selectables again.\r\n             * If the user starded in a scrollable area they will be reduced\r\n             * to the current area. Prevent the exclusion of these if a range-selection\r\n             * gets performed.\r\n             */\r\n            that.resolveSelectables();\r\n\r\n            // Traverse dom upwards to check if target is selectable\r\n            while (!that._selectables.includes(target)) {\r\n                if (!target.parentElement) {\r\n                    return;\r\n                }\r\n\r\n                target = target.parentElement;\r\n            }\r\n\r\n            const stored = that._selectedStore;\r\n            if (evt.shiftKey && stored.length) {\r\n                const reference = stored[stored.length - 1];\r\n\r\n                // Resolve correct range\r\n                const [preceding, following] = reference.compareDocumentPosition(target) & 4 ? [target, reference] : [reference, target];\r\n\r\n                const rangeItems = [...that._selectables.filter(el =>\r\n                    !stored.includes(el) &&\r\n                    (el.compareDocumentPosition(preceding) & 4) &&\r\n                    (el.compareDocumentPosition(following) & 2)\r\n                ), target];\r\n\r\n                that.select(rangeItems);\r\n            } else {\r\n                that._touchedElements.push(target);\r\n                that._dispatchEvent('onSelect', evt, {\r\n                    target\r\n                });\r\n            }\r\n        },\r\n\r\n        _delayedTapMove(evt) {\r\n            const {x, y} = simplifyEvent(evt);\r\n\r\n            // Check pixel threshold\r\n            if (abs((x + y) - (that._areaX1 + that._areaY1)) >= that.options.startThreshold) {\r\n\r\n                off(doc, ['mousemove', 'touchmove'], that._delayedTapMove, {passive: false});\r\n                on(doc, ['mousemove', 'touchmove'], that._onTapMove, {passive: false});\r\n                css(that._areaElement, 'display', 'block');\r\n\r\n                // New start position\r\n                that._onTapMove(evt);\r\n\r\n                // Fire event\r\n                that._dispatchEvent('onStart', evt);\r\n\r\n                // An action is recognized as single-select until\r\n                // the user performed a mutli-selection\r\n                that._singleClick = false;\r\n            }\r\n\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        },\r\n\r\n        _onTapMove(evt) {\r\n            const {x, y} = simplifyEvent(evt);\r\n            const scon = that._targetContainer;\r\n            const ss = that._scrollSpeed;\r\n            that._areaX2 = x;\r\n            that._areaY2 = y;\r\n\r\n            if (that._scrollAvailable && (ss.y !== null || ss.x !== null)) {\r\n\r\n                // Continous scrolling\r\n                requestAnimationFrame(function scroll() {\r\n\r\n                    // Scrolling is not anymore required\r\n                    if (ss.y === null && ss.x === null) {\r\n                        return;\r\n                    }\r\n\r\n                    /**\r\n                     * If the value exeeds the scrollable area it will\r\n                     * be set to the max / min value. So change only\r\n                     */\r\n                    const {scrollTop, scrollLeft} = scon;\r\n\r\n                    // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\r\n                    if (ss.y !== null) {\r\n                        scon.scrollTop += ceil(ss.y / that.options.scrollSpeedDivider);\r\n                        that._areaY1 -= scon.scrollTop - scrollTop;\r\n                    }\r\n\r\n                    if (ss.x !== null) {\r\n                        scon.scrollLeft += ceil(ss.x / that.options.scrollSpeedDivider);\r\n                        that._areaX1 -= scon.scrollLeft - scrollLeft;\r\n                    }\r\n\r\n                    /**\r\n                     * We changed the start coordinates ->  redraw the selectiona area\r\n                     * We changed the dimensions of the area element -> re-calc selected elements\r\n                     * The selected elements array has been changed -> fire event\r\n                     */\r\n                    that._redrawArea();\r\n                    that._updatedTouchingElements();\r\n                    that._dispatchEvent('onMove', evt);\r\n\r\n                    // Keep scrolling even if the user stops to move his pointer\r\n                    requestAnimationFrame(scroll);\r\n                });\r\n            } else {\r\n\r\n                /**\r\n                 * Perform redraw only if scrolling is not active.\r\n                 * If scrolling is active this area is getting re-dragwed by the\r\n                 * anonymized scroll function.\r\n                 */\r\n                that._redrawArea();\r\n                that._updatedTouchingElements();\r\n                that._dispatchEvent('onMove', evt);\r\n            }\r\n\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        },\r\n\r\n        _manualScroll(evt) {\r\n            const {scrollSpeedDivider} = that.options;\r\n            that._scrollSpeed.y += scrollSpeedDivider * (evt.wheelDeltaY * -1);\r\n            that._scrollSpeed.x += scrollSpeedDivider * (evt.wheelDeltaX * -1);\r\n            that._onTapMove(evt);\r\n\r\n            // Prevent defaul scrolling behaviour, eg. page scrolling\r\n            evt.preventDefault();\r\n        },\r\n\r\n        _redrawArea() {\r\n            const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = that._targetContainer;\r\n            const brect = that._targetBoundary;\r\n            const ss = that._scrollSpeed;\r\n            let x = that._areaX2;\r\n            let y = that._areaY2;\r\n\r\n            if (x < brect.left) {\r\n                ss.x = scrollLeft ? -abs(brect.left - x) : null;\r\n                x = brect.left;\r\n            } else if (x > brect.left + brect.width) {\r\n                ss.x = scrollWidth - scrollLeft - clientWidth ? abs(brect.left + brect.width - x) : null;\r\n                x = brect.left + brect.width;\r\n            } else {\r\n                ss.x = null;\r\n            }\r\n\r\n            if (y < brect.top) {\r\n                ss.y = scrollTop ? -abs(brect.top - y) : null;\r\n                y = brect.top;\r\n            } else if (y > brect.top + brect.height) {\r\n                ss.y = scrollHeight - scrollTop - clientHeight ? abs(brect.top + brect.height - y) : null;\r\n                y = brect.top + brect.height;\r\n            } else {\r\n                ss.y = null;\r\n            }\r\n\r\n            const x3 = min(that._areaX1, x);\r\n            const y3 = min(that._areaY1, y);\r\n            const x4 = max(that._areaX1, x);\r\n            const y4 = max(that._areaY1, y);\r\n\r\n            Object.assign(that._areaElement.style, {\r\n                top: `${y3}px`,\r\n                left: `${x3}px`,\r\n                width: `${x4 - x3}px`,\r\n                height: `${y4 - y3}px`\r\n            });\r\n        },\r\n\r\n        _onTapStop(evt, noevent) {\r\n\r\n            // Remove event handlers\r\n            off(doc, ['mousemove', 'touchmove'], that._delayedTapMove);\r\n            off(doc, ['touchmove', 'mousemove'], that._onTapMove);\r\n            off(doc, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\r\n\r\n            if (evt && that._singleClick && that.options.singleClick) {\r\n                that._onSingleTap(evt);\r\n            } else if (!that._singleClick && !noevent) {\r\n                that._updatedTouchingElements();\r\n                that._dispatchEvent('onStop', evt);\r\n            }\r\n\r\n            // Reset scroll speed\r\n            that._scrollSpeed = {x: null, y: null};\r\n\r\n            // Unbind mouse scrolling listener\r\n            off(window, 'wheel', that._manualScroll);\r\n\r\n            // Remove selection-area from dom\r\n            that._clippingElement.remove();\r\n\r\n            // Enable default select event\r\n            off(doc, 'selectstart', preventDefault);\r\n            css(that._areaElement, 'display', 'none');\r\n        },\r\n\r\n        _updatedTouchingElements() {\r\n            const {_touchedElements, _selectables, _areaElement, options} = that;\r\n\r\n            // Filter event\r\n            const filterEvent = options.selectionFilter && options.selectionFilter.bind(that);\r\n            const filterEventOk = typeof filterEvent === 'function';\r\n\r\n            const {mode} = options;\r\n            const areaRect = _areaElement.getBoundingClientRect();\r\n\r\n            // Update\r\n            const touched = [];\r\n            const added = [];\r\n            const removed = [];\r\n\r\n            // Itreate over the selectable elements\r\n            for (let i = 0, n = _selectables.length, node; node = _selectables[i], i < n; i++) {\r\n\r\n                // Check if area intersects element\r\n                if (intersects(areaRect, node.getBoundingClientRect(), mode)) {\r\n\r\n                    // Fire filter event\r\n                    if (filterEventOk &&\r\n                        !filterEvent.call(that, {\r\n                            selection: that,\r\n                            eventName: 'selectionFilter',\r\n                            element: node\r\n                        })\r\n                    ) continue;\r\n\r\n                    // Check if the element wasn't present in the last selection.\r\n                    if (!_touchedElements.includes(node)) {\r\n                        added.push(node);\r\n                    }\r\n\r\n                    touched.push(node);\r\n                }\r\n            }\r\n\r\n            // Check which elements where removed since last selection\r\n            for (let i = 0, n = _touchedElements.length, el; el = _touchedElements[i], i < n; i++) {\r\n                if (!touched.includes(el)) {\r\n                    removed.push(el);\r\n                }\r\n            }\r\n\r\n            // Save\r\n            that._touchedElements = touched;\r\n            that._changedElements = {added, removed};\r\n        },\r\n\r\n        _dispatchEvent(eventName, originalEvent, additional = {}) {\r\n            const event = that.options[eventName];\r\n\r\n            // Validate function\r\n            if (typeof event === 'function') {\r\n                return event.call(that, {\r\n                    selection: that,\r\n                    areaElement: that._areaElement,\r\n                    selectedElements: that._touchedElements.concat(that._selectedStore),\r\n                    changedElements: that._changedElements,\r\n                    eventName,\r\n                    originalEvent,\r\n                    ...additional\r\n                });\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Can be used if during a selection elements have been added.\r\n         * Will update everything which can be selected.\r\n         */\r\n        resolveSelectables() {\r\n\r\n            // Resolve selectors\r\n            that._selectables = selectAll(that.options.selectables);\r\n        },\r\n\r\n        /**\r\n         * Saves the current selection for the next selecion.\r\n         * Allows multiple selections.\r\n         */\r\n        keepSelection() {\r\n            for (let i = 0, n = that._touchedElements.length, el; el = that._touchedElements[i], i < n; i++) {\r\n                if (!that._selectedStore.includes(el)) {\r\n                    that._selectedStore.push(el);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Clear the elements which where saved by 'keepSelection()'.\r\n         */\r\n        clearSelection() {\r\n            that._selectedStore = [];\r\n        },\r\n\r\n        /**\r\n         * Removes an particular element from the selection.\r\n         */\r\n        removeFromSelection(el) {\r\n            removeElement(that._selectedStore, el);\r\n            removeElement(that._touchedElements, el);\r\n        },\r\n\r\n        /**\r\n         * @returns {Array} Selected elements\r\n         */\r\n        getSelection() {\r\n            return that._selectedStore;\r\n        },\r\n\r\n        /**\r\n         * Cancel the current selection process.\r\n         * @param keepEvent {boolean} true to fire the onStop listener after cancel.\r\n         */\r\n        cancel(keepEvent = false) {\r\n            that._onTapStop(null, !keepEvent);\r\n        },\r\n\r\n        /**\r\n         * Set or get an option.\r\n         * @param   {string} name\r\n         * @param   {*}      value\r\n         * @return  {*}      the new value\r\n         */\r\n        option(name, value) {\r\n            const {options} = that;\r\n            return value === null ? options[name] : (options[name] = value);\r\n        },\r\n\r\n        /**\r\n         * Disable the selection functinality.\r\n         */\r\n        disable() {\r\n            that._bindStartEvents('off');\r\n        },\r\n\r\n        /**\r\n         * Unbinds all events and removes the area-element\r\n         */\r\n        destroy() {\r\n            that.disable();\r\n            that._clippingElement.remove();\r\n        },\r\n\r\n        /**\r\n         * Disable the selection functinality.\r\n         */\r\n        enable() {\r\n            that._bindStartEvents('on');\r\n        },\r\n\r\n        /**\r\n         * Manually select elements\r\n         * @param query - CSS Query, can be an array of queries\r\n         */\r\n        select(query) {\r\n            const {_touchedElements, _selectedStore} = that;\r\n            const elements = selectAll(query).filter(el =>\r\n                !_touchedElements.includes(el) &&\r\n                !_selectedStore.includes(el)\r\n            );\r\n\r\n            that._changedElements.added = elements;\r\n            that._selectedStore.push(...elements);\r\n            that._dispatchEvent('onMove', null);\r\n\r\n            this._updatedTouchingElements();\r\n            that._dispatchEvent('onStop', null);\r\n            return that;\r\n        }\r\n    };\r\n\r\n    // Initialize\r\n    that._init();\r\n\r\n    return that;\r\n}\r\n\r\n// Export utils\r\nSelection.utils = {\r\n    on,\r\n    off,\r\n    css,\r\n    intersects,\r\n    selectAll,\r\n    eventPath,\r\n    removeElement\r\n};\r\n\r\n/**\r\n * Create selection instance\r\n * @param {Object} [options]\r\n */\r\nSelection.create = options => new Selection(options);\r\n\r\n// Set version\r\nSelection.version = '1.1.1';\r\n\r\n// Export API\r\nexport default Selection;\r\n"],"sourceRoot":""}